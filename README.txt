Για την ολοκλήρωση της εργασίας υλοποίησα 3 αρχεία:jobCommander.c , jobExecutorServer.c , queue.h

Ο jobCommander έχει την λειτουργία να στένει εντολές στον server.Αρχικά δημιουργεί 2 fifo ένα για γράψιμο στον server
και ένα για διάβασμα από τον server.Στην συνέχεια είτε ανοίγει τον server είτε του στέλνει αμέσως κάποια λειτουργία αν ο server είναι ανοιχτός.
Για να καταλάβει ο server ότι πρόκειται να εκτελεστεί ένας commander ο commander του στέλνει ένα SIGUSR1 σήμα.Έπειτα ανάλογα με τις λειτουργείες 
διακρίνουμε 5 περιπτώσεις ανάλογα με το ποιο είναι το argv[1] του jobCommander:setConcurrency,stop,poll,exit,issueJob
Κάθε commander στέλνει  μια από αυτές στον server και αφού τελειώσει κάνει unlinck τα fifo που δημιουργήσε.

Ο jobExecutorServer έχει την λειτουργία να διαβάζει από το fifo όταν λαμβάνει το SIGUSR1 σήμα από τον commander και να εκτελεί μια από 
τις εντολές:setConcurrency,stop,poll,exit,issueJob . Αρχίκα όταν εκτελεστεί δημιουργεί ενα txt αρχείο και γράφει το pid ώστε ο commander να 
ξέρει αν ο server είναι ενεργός αλλά και που να στείλει το σήμα.Έπειτα μπαίνει σε ένα loop και μέχρις ώτου να τερματιστεί εκτελεί εντολές από 
διάφορους commanders

Το αρχείο queue.h  περιέχει την δόμη της ουράς που χρησιμοποίειται για να αποθηκεύονται οι διεργασίες στον server.
ΣΧΕΔΙΑΣΤΙΚΗ ΕΠΙΛΟΓΗ ΓΙΑ ΤΗΝ ΟΥΡΑ ΚΑΙ ΤΙΣ ΔΙΕΡΓΑΣΙΕΣ:
Η εκφώνηση ζητούσε όταν εκτελείται μια διεργασία να αφαιρείται αμέσως από την ουρά,παρολά αυτά επείδη σε αυτήν την 
περιπτώση θα χρειαζόταν να φτιάξω άλλη μια δόμη που θα σπαταλούσε χώρο επελέξα να κανώ το εξής:
Στο value των στοιχείων της ουράς πρόσθεσα το process_pid το οποίο όταν μια διεργασία είναι σε αναμονή είναι -1 
και όταν εκτελείται είναι το pid της.Με αυτόν τον τρόπο έχοντας μόνο μια δομή μπορω να ξέρω ποιες διεργασίες 
είναι σε αναμονή και ποιες σε εκτελέση.Όταν μια διεργασία τερματισει και σταλθεί το σημα SIGCHLD αφαιρείται από την
ουρά.Επομένως η διαφόρα είναι ότι μια διεργασία βγαίνει από την ουρά οταν τερματισει όχι όταν εκτελεστεί χωρίς φυσικά 
αυτό να επηρεαζεί τις υπολοιπές λειτουργείες (poll queued,poll running, stop κλπ).

Ακόμη υλοποίησα τα 2 bash scripts multijob.sh και allJobsStop.sh 
Στο multijob.sh για κάθε γραμμή κάθε αρχείου εκτελείται το ./jobCommander issueJob "γραμμή".

Στο allJobsStop.sh εκτελείται ο commander με την εντολή poll queued και μέτα για κάθε job_id
που είναι queued εκτελείται ο commander με stop job_id.Επείται εκτελείται ο commander με την
εντολή poll running και με την ίδια διαδικασία κάνουμε stop τις διεργασίες που εκτελούνται.

